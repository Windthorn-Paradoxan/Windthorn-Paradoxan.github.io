<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EMx Loop Visualizer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #020617;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      color: #e5e7eb;
    }
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    #panel {
      position: absolute;
      top: 16px;
      left: 16px;
      background: rgba(15, 23, 42, 0.92);
      border-radius: 8px;
      border: 1px solid #334155;
      padding: 14px 16px;
      max-width: 340px;
      font-size: 12px;
      z-index: 10;
    }
    #panel h3 {
      margin: 0 0 8px 0;
      font-size: 15px;
      color: #38bdf8;
    }
    .row {
      display: flex;
      align-items: center;
      margin: 4px 0;
      gap: 6px;
    }
    .row label {
      flex: 0 0 90px;
      color: #9ca3af;
    }
    .row span {
      font-weight: 600;
    }
    input[type="number"] {
      background: #020617;
      border: 1px solid #1f2937;
      border-radius: 4px;
      padding: 4px 6px;
      color: #e5e7eb;
      width: 90px;
      font-size: 12px;
    }
    button {
      background: #1d4ed8;
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      color: #e5e7eb;
      font-size: 12px;
      cursor: pointer;
      margin-right: 4px;
    }
    button:hover {
      background: #2563eb;
    }
    button.secondary {
      background: #0f172a;
      border: 1px solid #1f2937;
    }
    button.secondary:hover {
      background: #020617;
    }
    .pill {
      display: inline-block;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      background: #0f172a;
      border: 1px solid #1f2937;
      margin-top: 4px;
    }
    .label-inline {
      color: #9ca3af;
      font-size: 11px;
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div id="panel">
    <h3>ðŸœ€ EMx Loop Visualizer</h3>

    <div class="row">
      <label for="tokenInput">Input token:</label>
      <input type="number" id="tokenInput" value="345" min="0" max="100000" />
    </div>

    <div class="row">
      <label>Tick:</label>
      <span id="tickVal">0</span>
    </div>
    <div class="row">
      <label>Coords (x,y,z):</label>
      <span id="coordVal">(0,0,0)</span>
    </div>
    <div class="row">
      <label>T-set:</label>
      <span id="tsetVal">T0</span>
    </div>
    <div class="row">
      <label>Phase (mod 24):</label>
      <span id="phaseVal">0.00</span>
    </div>

    <div class="row" style="margin-top: 8px">
      <button id="stepBtn">Step</button>
      <button id="playBtn">Play</button>
      <button class="secondary" id="resetBtn">Reset</button>
    </div>

    <div class="label-inline">
      Branches: this demo runs a single deterministic branch for clarity.
    </div>

    <div class="pill">
      Legend: gray = lattice nodes, cyan = trail, red = current state
    </div>
  </div>

  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // ==============================
    // EMx core-ish helpers (JS)
    // ==============================

    const TSet = {
      T0: "T0",
      T1: "T1",
      T2: "T2",
      T3: "T3",
      T4: "T4",
    };

    class EMxState {
      constructor(x, y, z, tSet, separated) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.tSet = tSet;
        this.separated = separated || [false, false, false];
      }
    }

    class EMxContext {
      constructor() {
        this.phase = 0.0;
        this.history = [];
        this.hashesSeen = new Set();
        this.tick = 0;
      }
    }

    // 27 T0 lattice states: {-1,0,1}^3 (we don't visually distinguish +0/-0)
    const T0_LATTICE = [];
    for (let x of [-1, 0, 1]) {
      for (let y of [-1, 0, 1]) {
        for (let z of [-1, 0, 1]) {
          T0_LATTICE.push(new EMxState(x, y, z, TSet.T0, [false, false, false]));
        }
      }
    }

    // T4-like directions for W in [0..15]
    const T4_DIRECTIONS = [
      [-1, +1, +1],
      [+1, -1, +1],
      [+1, +1, -1],
      [-1, -1, +1],
      [-1, +1, -1],
      [+1, -1, -1],
      [-1, -1, -1],
      [+1, +1, +1],
      [0, +1, +1],
      [0, -1, +1],
      [+1, 0, +1],
      [-1, 0, +1],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
    ];

    function decodeDirectionFromW(W) {
      const idx = Math.max(0, Math.min(15, W | 0));
      const v = T4_DIRECTIONS[idx];
      return { x: v[0], y: v[1], z: v[2] };
    }

    // simple 32bit hash (xorshift-ish)
    function emxHash(inputToken, tick, salt) {
      let x = (inputToken | 0) ^ (tick * 0x9e3779b9) ^ salt;
      x ^= x << 13;
      x ^= x >>> 17;
      x ^= x << 5;
      return x >>> 0; // unsigned
    }

    // map 2 bits -> {-1,0,+1}
    function bitsToTernary(twoBits) {
      switch (twoBits) {
        case 0: // 00
          return 0;
        case 1: // 01
          return +1;
        case 2: // 10
          return -1;
        case 3: // 11
          return 0;
        default:
          return 0;
      }
    }

    function ternaryJitter(hashVal) {
      const dxBits = (hashVal >>> 0) & 0b11;
      const dyBits = (hashVal >>> 2) & 0b11;
      const dzBits = (hashVal >>> 4) & 0b11;
      return {
        dx: bitsToTernary(dxBits),
        dy: bitsToTernary(dyBits),
        dz: bitsToTernary(dzBits),
      };
    }

    function makePacket(inputToken, tick) {
      const raw = (inputToken + tick * 17) & 0x3ff; // 0..1023
      const W = raw & 0x0f;
      const H = (raw >>> 4) & 0x03;
      let E = 0;
      // gray echo
      E = (W ^ (W >>> 1)) & 0x0f;
      return { W, H, E };
    }

    function clamp(val, min, max) {
      return val < min ? min : val > max ? max : val;
    }

    function snapSignedZero(v) {
      // If near 0, snap to 0 exactly
      const eps = 0.15;
      if (Math.abs(v) < eps) return 0.0;
      return v;
    }

    function projectToTSet(state, phaseMod) {
      const mag = Math.sqrt(state.x * state.x + state.y * state.y + state.z * state.z);
      let t = TSet.T0;
      if (mag <= 0.1) {
        t = TSet.T0;
      } else if (mag <= 0.8) {
        t = TSet.T1;
      } else if (mag <= 1.2) {
        t = TSet.T2;
      } else if (mag <= 1.8) {
        t = TSet.T3;
      } else {
        t = TSet.T4;
      }
      state.tSet = t;
      return state;
    }

    function emxInitState(inputToken) {
      const idx = Math.abs(inputToken) % T0_LATTICE.length;
      const base = T0_LATTICE[idx];
      const ctx = new EMxContext();
      // clone state so we don't mutate lattice
      const state = new EMxState(base.x, base.y, base.z, base.tSet, [...base.separated]);
      return { state, ctx };
    }

    function emxStep(state, ctx, inputToken, salt) {
      ctx.tick += 1;

      // anchor from T0
      const baseIdx = (inputToken + ctx.tick) % T0_LATTICE.length;
      const anchor = T0_LATTICE[baseIdx];

      // jitter
      const h = emxHash(inputToken, ctx.tick, salt);
      const { dx, dy, dz } = ternaryJitter(h);

      // packet â†’ direction
      const packet = makePacket(inputToken, ctx.tick);
      const dir = decodeDirectionFromW(packet.W);

      const sx = Math.sign(dir.x);
      const sy = Math.sign(dir.y);
      const sz = Math.sign(dir.z);

      let nx = anchor.x + sx + dx;
      let ny = anchor.y + sy + dy;
      let nz = anchor.z + sz + dz;

      nx = snapSignedZero(clamp(nx, -1, 1));
      ny = snapSignedZero(clamp(ny, -1, 1));
      nz = snapSignedZero(clamp(nz, -1, 1));

      const newState = new EMxState(nx, ny, nz, state.tSet, [...state.separated]);

      // simple rupture / separation when jitter large
      const energy = Math.abs(dx) + Math.abs(dy) + Math.abs(dz);
      if (energy >= 2) {
        const absVals = [Math.abs(nx), Math.abs(ny), Math.abs(nz)];
        let axis = 0;
        if (absVals[1] >= absVals[0] && absVals[1] >= absVals[2]) axis = 1;
        else if (absVals[2] >= absVals[0] && absVals[2] >= absVals[1]) axis = 2;
        newState.separated[axis] = true;
      }

      // phase accumulation (O10)
      ctx.phase = ctx.phase + inputToken / 118.6;
      const phaseMod = ((ctx.phase % 24) + 24) % 24;

      // project to T-set
      projectToTSet(newState, phaseMod);

      // no-clone context (for info only)
      const sig = `${newState.x},${newState.y},${newState.z},${newState.tSet}`;
      ctx.hashesSeen.add(sig);

      ctx.history.push(newState);
      return { state: newState, ctx, phaseMod };
    }

    // ==============================
    // Three.js Visualization
    // ==============================

    let scene, camera, renderer;
    let latticeMeshes = [];
    let currentMesh;
    let trailGeometry, trailLine;
    let emxState, emxCtx;
    let playing = false;
    let lastStepTime = 0;
    const STEP_INTERVAL = 300; // ms between automatic steps

    const tickSpan = document.getElementById("tickVal");
    const coordSpan = document.getElementById("coordVal");
    const tsetSpan = document.getElementById("tsetVal");
    const phaseSpan = document.getElementById("phaseVal");
    const tokenInput = document.getElementById("tokenInput");

    function initScene() {
      const container = document.getElementById("container");

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x020617);

      const width = window.innerWidth;
      const height = window.innerHeight;

      camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
      camera.position.set(4, 4, 6);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      container.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0x404040, 1.3);
      scene.add(ambient);

      const point = new THREE.PointLight(0xffffff, 1.2, 50);
      point.position.set(8, 10, 10);
      scene.add(point);

      // Axes
      const axes = new THREE.AxesHelper(2.5);
      scene.add(axes);

      // Lattice nodes
      const nodeGeom = new THREE.SphereGeometry(0.06, 12, 12);
      const nodeMat = new THREE.MeshPhongMaterial({
        color: 0x4b5563,
        transparent: true,
        opacity: 0.8,
      });

      const scale = 1.0; // distance between coords

      for (let x of [-1, 0, 1]) {
        for (let y of [-1, 0, 1]) {
          for (let z of [-1, 0, 1]) {
            const mesh = new THREE.Mesh(nodeGeom, nodeMat.clone());
            mesh.position.set(x * scale, y * scale, z * scale);
            scene.add(mesh);
            latticeMeshes.push(mesh);
          }
        }
      }

      // current state marker
      const currentGeom = new THREE.SphereGeometry(0.14, 18, 18);
      const currentMat = new THREE.MeshPhongMaterial({
        color: 0xef4444,
        emissive: 0xef4444,
        emissiveIntensity: 0.7,
      });
      currentMesh = new THREE.Mesh(currentGeom, currentMat);
      scene.add(currentMesh);

      // trail line
      trailGeometry = new THREE.BufferGeometry();
      const trailMat = new THREE.LineBasicMaterial({
        color: 0x22d3ee,
        transparent: true,
        opacity: 0.75,
      });
      trailLine = new THREE.Line(trailGeometry, trailMat);
      scene.add(trailLine);

      window.addEventListener("resize", onWindowResize);
    }

    function onWindowResize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    function resetEMx() {
      const token = parseInt(tokenInput.value || "0", 10) || 0;
      const base = emxInitState(token);
      emxState = base.state;
      emxCtx = base.ctx;
      updateUI(0, emxState, 0);
      updateVisualsFromHistory();
    }

    function updateUI(phaseMod, state, phaseVal) {
      tickSpan.textContent = emxCtx.tick.toString();
      coordSpan.textContent = `(${state.x.toFixed(1)}, ${state.y.toFixed(
        1
      )}, ${state.z.toFixed(1)})`;
      tsetSpan.textContent = state.tSet;
      phaseSpan.textContent = phaseMod.toFixed(2);
    }

    function updateVisualsFromHistory() {
      if (!emxCtx || !emxCtx.history.length) {
        currentMesh.position.set(0, 0, 0);
        trailGeometry.setFromPoints([]);
        return;
      }

      const points = [];
      const scale = 1.0;

      for (const s of emxCtx.history) {
        points.push(
          new THREE.Vector3(s.x * scale, s.y * scale, s.z * scale)
        );
      }

      trailGeometry.setFromPoints(points);

      const last = emxCtx.history[emxCtx.history.length - 1];
      currentMesh.position.set(last.x * scale, last.y * scale, last.z * scale);
    }

    function stepOnce() {
      const token = parseInt(tokenInput.value || "0", 10) || 0;
      const salt = 7919; // single branch here
      const { state, ctx, phaseMod } = emxStep(emxState, emxCtx, token, salt);
      emxState = state;
      emxCtx = ctx;
      updateUI(phaseMod, emxState, emxCtx.phase);
      updateVisualsFromHistory();
    }

    function animate(time) {
      requestAnimationFrame(animate);

      // gentle rotation
      scene.rotation.y += 0.002;

      if (playing) {
        if (time - lastStepTime > STEP_INTERVAL) {
          stepOnce();
          lastStepTime = time;
        }
      }

      renderer.render(scene, camera);
    }

    // ==============================
    // UI wiring
    // ==============================

    document.addEventListener("DOMContentLoaded", () => {
      initScene();
      resetEMx();
      animate(0);

      const stepBtn = document.getElementById("stepBtn");
      const playBtn = document.getElementById("playBtn");
      const resetBtn = document.getElementById("resetBtn");

      stepBtn.addEventListener("click", () => {
        playing = false;
        playBtn.textContent = "Play";
        stepOnce();
      });

      playBtn.addEventListener("click", () => {
        playing = !playing;
        playBtn.textContent = playing ? "Pause" : "Play";
      });

      resetBtn.addEventListener("click", () => {
        playing = false;
        playBtn.textContent = "Play";
        resetEMx();
      });

      tokenInput.addEventListener("change", () => {
        playing = false;
        playBtn.textContent = "Play";
        resetEMx();
      });
    });
  </script>
</body>
</html>
