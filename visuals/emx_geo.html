<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EMx Geometry Transform</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 20% 20%, #222 0, #050509 60%);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    .frame {
      position: relative;
      width: min(78vmin, 720px);
      aspect-ratio: 1 / 1;
      border-radius: 32px;
      background: radial-gradient(circle at 50% 15%, #26263f 0, #090911 60%);
      box-shadow:
        0 0 40px rgba(0,0,0,0.9),
        0 0 80px rgba(60,180,255,0.18),
        inset 0 0 20px rgba(0,0,0,0.6);
      overflow: hidden;
    }
    svg {
      width: 100%;
      height: 100%;
      display: block;
    }
    .bg-grid line {
      stroke: rgba(255,255,255,0.055);
      stroke-width: 0.4;
    }
    .axis {
      stroke: rgba(255,255,255,0.18);
      stroke-width: 1.1;
      stroke-linecap: round;
    }
    .lemniscate-path {
      fill: none;
      stroke: rgba(160,200,255,0.65);
      stroke-width: 1.4;
      stroke-linecap: round;
      stroke-dasharray: 4 6;
      stroke-linejoin: round;
    }
    .lemniscate-dot {
      fill: rgba(255,255,255,0.88);
    }
    .main-shape {
      fill: rgba(90,210,255,0.16);
      stroke: rgba(90,210,255,0.88);
      stroke-width: 2.4;
      stroke-linejoin: round;
      filter: drop-shadow(0 0 10px rgba(60,190,255,0.8));
    }
    .halo {
      fill: none;
      stroke-width: 0.9;
      stroke: rgba(255,255,255,0.2);
      stroke-dasharray: 2 4;
    }
    .null-pulse {
      fill: rgba(255,255,255,0.06);
      stroke: rgba(255,255,255,0.2);
      stroke-width: 0.7;
    }
  </style>
</head>
<body>
  <div class="frame">
    <svg viewBox="-100 -100 200 200">
      <!-- subtle grid -->
      <g class="bg-grid">
        <!-- verticals -->
        <line x1="-100" y1="-100" x2="-100" y2="100" />
        <line x1="-50" y1="-100" x2="-50" y2="100" />
        <line x1="0" y1="-100" x2="0" y2="100" />
        <line x1="50" y1="-100" x2="50" y2="100" />
        <line x1="100" y1="-100" x2="100" y2="100" />
        <!-- horizontals -->
        <line x1="-100" y1="-100" x2="100" y2="-100" />
        <line x1="-100" y1="-50" x2="100" y2="-50" />
        <line x1="-100" y1="0" x2="100" y2="0" />
        <line x1="-100" y1="50" x2="100" y2="50" />
        <line x1="-100" y1="100" x2="100" y2="100" />
      </g>

      <!-- axes -->
      <line class="axis" x1="-100" y1="0" x2="100" y2="0" />
      <line class="axis" x1="0" y1="-100" x2="0" y2="100" />

      <!-- lemniscate (∞) guide -->
      <path id="lemniscate" class="lemniscate-path" />

      <!-- moving dot on lemniscate -->
      <circle id="lemniscateDot" class="lemniscate-dot" r="1.8" />

      <!-- pulsing null center -->
      <circle id="nullPulse" class="null-pulse" r="6" />
      <circle class="halo" r="20" />
      <circle class="halo" r="40" />

      <!-- main morphing shape -->
      <polygon id="mainShape" class="main-shape" />
    </svg>
  </div>

  <script>
    // ----- helpers -----
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function lerpPoint(p, q, t) {
      return { x: lerp(p.x, q.x, t), y: lerp(p.y, q.y, t) };
    }

    // ----- base shapes in normalized radius space -----
    // main radius for polygon vertices
    const R = 55;

    function regularPolygon(n, phase = 0) {
      const pts = [];
      for (let i = 0; i < n; i++) {
        const theta = 2 * Math.PI * (i / n) + phase;
        pts.push({ x: R * Math.cos(theta), y: R * Math.sin(theta) });
      }
      return pts;
    }

    // three "pure" shapes representing different EMx polarities
    const SHAPE_TRIANGLE = regularPolygon(3, -Math.PI / 2);
    const SHAPE_SQUARE   = regularPolygon(4, Math.PI / 4);
    const SHAPE_HEX      = regularPolygon(6, Math.PI / 6);

    // resample so all shapes have same number of vertices (6)
    function resampleTo6(pts) {
      if (pts.length === 6) return pts;
      const result = [];
      for (let i = 0; i < 6; i++) {
        const t = i / 6;
        const idx = t * pts.length;
        const i0 = Math.floor(idx) % pts.length;
        const i1 = (i0 + 1) % pts.length;
        const frac = idx - i0;
        result.push(lerpPoint(pts[i0], pts[i1], frac));
      }
      return result;
    }

    const S_TRI = resampleTo6(SHAPE_TRIANGLE);
    const S_SQR = resampleTo6(SHAPE_SQUARE);
    const S_HEX = resampleTo6(SHAPE_HEX);

    // sequence: triangle → square → hex → triangle ...
    const KEY_SHAPES = [S_TRI, S_SQR, S_HEX];

    function mixShapes(a, b, t) {
      const res = [];
      for (let i = 0; i < a.length; i++) {
        res.push(lerpPoint(a[i], b[i], t));
      }
      return res;
    }

    function pointsToString(pts) {
      return pts.map(p => `${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
    }

    // ----- lemniscate path (Bernoulli) -----
    const lemniscatePath = document.getElementById("lemniscate");
    const lemniscateDot = document.getElementById("lemniscateDot");
    const mainShape = document.getElementById("mainShape");
    const nullPulse = document.getElementById("nullPulse");

    // param a sets lobe size
    const L_A = 45;

    function lemniscatePoint(t) {
      // t in [0, 2π)
      const c = Math.cos(t);
      const s = Math.sin(t);
      const denom = 1 + c * c;
      const x = (L_A * Math.SQRT2 * c) / denom;
      const y = (L_A * Math.SQRT2 * c * s) / denom;
      return { x, y };
    }

    function buildLemniscatePath(samples = 240) {
      const pts = [];
      for (let i = 0; i <= samples; i++) {
        const t = (i / samples) * 2 * Math.PI;
        pts.push(lemniscatePoint(t));
      }
      const d = pts
        .map((p, i) => (i === 0 ? `M ${p.x} ${p.y}` : `L ${p.x} ${p.y}`))
        .join(" ");
      lemniscatePath.setAttribute("d", d);
      return pts;
    }

    const lemniscateSamples = buildLemniscatePath(360);

    // ----- animation loop -----
    let startTime = null;

    function animate(timestamp) {
      if (!startTime) startTime = timestamp;
      const t = (timestamp - startTime) / 1000; // seconds

      // shape blend phase: loop every 18s
      const cycle = 18;
      const phase = (t % cycle) / cycle; // [0,1)
      const seg = phase * KEY_SHAPES.length;
      const i0 = Math.floor(seg) % KEY_SHAPES.length;
      const i1 = (i0 + 1) % KEY_SHAPES.length;
      const localT = seg - i0;

      const mixed = mixShapes(KEY_SHAPES[i0], KEY_SHAPES[i1], 0.5 - 0.5 * Math.cos(localT * Math.PI));
      mainShape.setAttribute("points", pointsToString(mixed));

      // lemniscate dot moving slightly faster
      const dotPhase = (t * 0.35) % 1; // [0,1)
      const idx = Math.floor(dotPhase * lemniscateSamples.length);
      const nextIdx = (idx + 1) % lemniscateSamples.length;
      const frac = dotPhase * lemniscateSamples.length - idx;
      const dotPos = lerpPoint(lemniscateSamples[idx], lemniscateSamples[nextIdx], frac);
      lemniscateDot.setAttribute("cx", dotPos.x);
      lemniscateDot.setAttribute("cy", dotPos.y);

      // null center slow breathing
      const rBase = 6;
      const rPulse = 2.2 * Math.sin(t * 1.2);
      nullPulse.setAttribute("r", (rBase + rPulse).toFixed(2));

      // slight global rotation of main shape around center
      const rotAngle = Math.sin(t * 0.4) * 9; // ±9 degrees
      mainShape.setAttribute(
        "transform",
        `rotate(${rotAngle.toFixed(2)} 0 0) scale(${1 + 0.02 * Math.sin(t * 0.8)})`
      );

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  </script>
</body>
</html>
